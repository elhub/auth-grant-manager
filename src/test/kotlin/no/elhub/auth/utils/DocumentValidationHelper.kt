package no.elhub.auth.utils

import eu.europa.esig.dss.enumerations.ValidationLevel
import eu.europa.esig.dss.model.DSSDocument
import eu.europa.esig.dss.model.InMemoryDocument
import eu.europa.esig.dss.model.x509.CertificateToken
import eu.europa.esig.dss.pades.validation.PDFDocumentValidator
import eu.europa.esig.dss.spi.validation.CommonCertificateVerifier
import eu.europa.esig.dss.spi.x509.CommonTrustedCertificateSource
import io.kotest.matchers.shouldBe
import no.elhub.auth.config.loadCerts
import java.io.File

object DocumentValidationHelper {

    fun validateInitialDocumentSignature(documentByteArray: ByteArray) {
        val document: DSSDocument = InMemoryDocument(documentByteArray)

        // In tests, certificate generated by CertsSetupExtension will be used to sign the document
        // We therefore need to add this to the trusted list
        val i = File(TestCertificateUtil.Constants.CERTIFICATE_LOCATION)
        val testCertificate = CertificateToken(loadCerts(i).single())

        val verifier = CommonCertificateVerifier().apply {
            setTrustedCertSources(CommonTrustedCertificateSource().also { it.addCertificate(testCertificate) })
        }

        val reports = PDFDocumentValidator(document).apply {
            setCertificateVerifier(verifier)
            setValidationLevel(ValidationLevel.BASIC_SIGNATURES)
        }.validateDocument()

        val simpleReport = reports.simpleReport

        // Verify that we only add one signature to the document
        val signatureIds = simpleReport.getSignatureIdList()
        signatureIds.size shouldBe 1

        val id = signatureIds.first()

        // Validate that the signature is valid
        simpleReport.isValid(id) shouldBe true

        // Validate that correct certificate is used
        val certificateChain = simpleReport.getCertificateChain(id)
        certificateChain.certificate.size shouldBe 1 // We expect only one certificate (self-signed) in the chain for this test

        val signingCertificateReference =
            certificateChain.certificate.first().id ?: throw IllegalStateException("Certificate reference is null, expected a valid certificate in the chain")

        // Validate that the signing certificate is the one we expect
        val signingCertificateWrapper = reports.diagnosticData.getUsedCertificateById(signingCertificateReference)
        val signingCertificateDN = signingCertificateWrapper.certificateDN
        val signingCertificateSerialNumber = signingCertificateWrapper.serialNumber

        signingCertificateDN shouldBe testCertificate.issuer.rfC2253
        signingCertificateSerialNumber shouldBe testCertificate.serialNumber.toString()
    }
}
