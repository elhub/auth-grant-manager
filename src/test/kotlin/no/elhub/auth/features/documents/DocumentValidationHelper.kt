package no.elhub.auth.features.documents

import eu.europa.esig.dss.enumerations.ValidationLevel
import eu.europa.esig.dss.model.DSSDocument
import eu.europa.esig.dss.model.InMemoryDocument
import eu.europa.esig.dss.model.x509.CertificateToken
import eu.europa.esig.dss.pades.validation.PDFDocumentValidator
import eu.europa.esig.dss.spi.validation.CommonCertificateVerifier
import eu.europa.esig.dss.spi.x509.CommonTrustedCertificateSource
import io.kotest.matchers.shouldBe
import org.apache.pdfbox.Loader
import org.verapdf.gf.foundry.VeraGreenfieldFoundryProvider
import org.verapdf.pdfa.Foundries
import org.verapdf.pdfa.PDFAParser
import org.verapdf.pdfa.PDFAValidator
import org.verapdf.pdfa.flavours.PDFAFlavour
import java.io.ByteArrayInputStream
import java.io.File
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate

const val CERT_TYPE = "X509"

fun ByteArray.validateFileIsSignedByUs() {
    val document: DSSDocument = InMemoryDocument(this)

    // In tests, certificate generated by CertsSetupExtension will be used to sign the document
    // We therefore need to add this to the trusted list
    val testCertificate =
        CertificateToken(
            File(TestCertificateUtil.Constants.CERTIFICATE_LOCATION)
                .inputStream()
                .use {
                    CertificateFactory
                        .getInstance(CERT_TYPE)
                        .generateCertificates(it)
                        .filterIsInstance<X509Certificate>()
                        .single()
                }
        )

    val verifier = CommonCertificateVerifier().apply {
        setTrustedCertSources(CommonTrustedCertificateSource().also { it.addCertificate(testCertificate) })
    }

    val reports = PDFDocumentValidator(document).apply {
        setCertificateVerifier(verifier)
        setValidationLevel(ValidationLevel.BASIC_SIGNATURES)
    }.validateDocument()

    val simpleReport = reports.simpleReport

    // Verify that we only add one signature to the document
    val signatureIds = simpleReport.getSignatureIdList()
    signatureIds.size shouldBe 1

    val id = signatureIds.first()

    // Validate that the signature is valid
    simpleReport.isValid(id) shouldBe true

    // Validate that correct certificate is used
    val certificateChain = simpleReport.getCertificateChain(id)
    certificateChain.certificate.size shouldBe 1 // We expect only one certificate (self-signed) in the chain for this test

    val signingCertificateReference =
        certificateChain.certificate.first().id
            ?: throw IllegalStateException("Certificate reference is null, expected a valid certificate in the chain")

    // Validate that the signing certificate is the one we expect
    val signingCertificateWrapper = reports.diagnosticData.getUsedCertificateById(signingCertificateReference)
    val signingCertificateDN = signingCertificateWrapper.certificateDN
    val signingCertificateSerialNumber = signingCertificateWrapper.serialNumber

    signingCertificateDN shouldBe testCertificate.issuer.rfC2253
    signingCertificateSerialNumber shouldBe testCertificate.serialNumber.toString()
}

fun ByteArray.validateFileIsPDFA2BCompliant(): Boolean {
    VeraGreenfieldFoundryProvider.initialise()
    val flavour = PDFAFlavour.PDFA_2_B
    ByteArrayInputStream(this).use { input ->
        Foundries.defaultInstance().createParser(input, flavour).use { parser: PDFAParser ->
            val validator: PDFAValidator =
                Foundries.defaultInstance().createValidator(flavour, false)
            return validator.validate(parser).isCompliant
        }
    }
}

fun ByteArray.getCustomMetaDataValue(
    key: String
): String? = Loader.loadPDF(this).use { doc ->
    val info = doc.documentInformation
    return info.getCustomMetadataValue(key)
}
